<style> body {margin: 0}</style>
<script src="https://greggman.github.io/webgl-lint/webgl-lint.js"></script>
<canvas style="width: 100%; height: 100%;"></canvas>
<script type="text/javascript">
  const canvas = document.querySelector('canvas');
  const gl = canvas.getContext("webgl2", {antialias: false})
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  const alignment = 1;
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);
  const vertexShaderSource = `#version 300 es
    in vec2 position;
    void main() {
      gl_Position = vec4(position * 2.0 - 1.0, 0, 1.0);
    }`;
  const fragmentShaderSource = `#version 300 es
    #define fc gl_FragCoord
    precision mediump float;
    out vec4 color;
    uniform vec2 resolution;

    uint rng_state;

    uint pcg() // Modified to use the global rng_state
    {
        rng_state = rng_state * 747796405u + 2891336453u;
        uint state = rng_state;
        uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        return (word >> 22u) ^ word;
    }

    void main()
    {
        rng_state = uint(fc.y * resolution.x + fc.x); // Initialize per pixel

        vec3 result = vec3(float(pcg()), float(pcg()), float(pcg())) / float(0xFFFFFFFFU);

        color = vec4(result, 1.0);
    }`
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  setPositions(program);
  const resolutionUniformLocation = gl.getUniformLocation(program, 'resolution');
  const draw = () => drawScene(resolutionUniformLocation);
  window.onresize = draw;
  draw()

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
      return shader;
    }
  }

  function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
      return program;
    }
  }

  function setPositions(program) {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      0.0, 0.0,
      1.0, 0.0,
      0.0, 1.0,

      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
    ]), gl.STATIC_DRAW);
    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    const positionLocation = gl.getAttribLocation(program, 'position');
    const size = 2; // 2 components per iteration
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
    let offset = 0; // start at the beginning of the buffer
    gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
    gl.enableVertexAttribArray(positionLocation);
  }

  function drawScene(resolutionUniformLocation) {
    const size = getIntrinsicSize(canvas);
    canvas.width = Math.round(size.width * window.devicePixelRatio);
    canvas.height = Math.round(size.height * window.devicePixelRatio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
    const primitiveType = gl.TRIANGLES;
    const offset = 0;
    const count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }

  function getIntrinsicSize(element) {
    const rect = element.getBoundingClientRect();
    const computedStyle = getComputedStyle(element);
    const scaleX = rect.width / parseFloat(computedStyle.width);
    const scaleY = rect.height / parseFloat(computedStyle.height);

    const intrinsicWidth = rect.width / scaleX;
    const intrinsicHeight = rect.height / scaleY;

    return { width: intrinsicWidth, height: intrinsicHeight };
  }
</script>