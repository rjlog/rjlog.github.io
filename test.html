<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RJ's test shader</title>
</head>
<style> * {margin: 0; width: 100%; height: 100%;}</style>
<script src="https://greggman.github.io/webgl-lint/webgl-lint.js"></script>
<canvas></canvas>
<script type="text/javascript">
    const canvas = document.querySelector('canvas');
    const gl = canvas.getContext("webgl2", {antialias: false})
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    const alignment = 1;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);
    const vertexShaderSource = `#version 300 es
    in vec2 position;
    void main() {
      gl_Position = vec4(position * 2.0 - 1.0, 0, 1.0);
    }`;
    const fragmentShaderSource = `#version 300 es
    #define fc gl_FragCoord
    precision highp float;
    precision highp int;
    out vec4 color;
    uniform vec2 resolution;
    uniform float time;

    uint rng_state;

    uint pcg(uint x)
    {
        uint state = x * 747796405u + 2891336453u;
        uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        return (word >> 22u) ^ word;
    }

    void main()
    {
        vec2 seed = fc.xy;
        seed += time;
        vec3 result = vec3(pcg(uint(seed.y * resolution.x + seed.x))) / float(0xFFFFFFFFU);
        color = vec4(result,1.0);
    }`
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);
    gl.useProgram(program);
    setPositions(program);
    const resolutionUniformLocation = gl.getUniformLocation(program, 'resolution');
    const timeUniform = gl.getUniformLocation(program, "time");
    let resized = true;
    window.onresize = () => resized = true;
    window.requestAnimationFrame(render)

    function render(timestamp) {
        if (resized) {
            resized = false;
            const size = getExactClientSize(canvas);
            canvas.width = Math.round(size.width * window.devicePixelRatio);
            canvas.height = Math.round(size.height * window.devicePixelRatio);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
        }
        gl.uniform1f(timeUniform, timestamp % 1000);

        const primitiveType = gl.TRIANGLES;
        const offset = 0;
        const count = 6;
        gl.drawArrays(primitiveType, offset, count);
        window.requestAnimationFrame(render)
    }

    function getExactClientSize(element) {
        const rect = element.getBoundingClientRect();
        const computedStyle = getComputedStyle(element);
        const scaleX = rect.width / parseFloat(computedStyle.width);
        const scaleY = rect.height / parseFloat(computedStyle.height);

        const intrinsicWidth = rect.width / scaleX;
        const intrinsicHeight = rect.height / scaleY;

        return {width: intrinsicWidth, height: intrinsicHeight};
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader;
        }
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
    }

    function setPositions(program) {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,

            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
        ]), gl.STATIC_DRAW);
        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        const positionLocation = gl.getAttribLocation(program, 'position');
        const size = 2; // 2 components per iteration
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
        let offset = 0; // start at the beginning of the buffer
        gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
        gl.enableVertexAttribArray(positionLocation);
    }
</script>