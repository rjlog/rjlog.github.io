<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RJ's test shader</title>
</head>
<style> * {margin: 0; width: 100%; height: 100%;}</style>
<script src="https://greggman.github.io/webgl-lint/webgl-lint.js"></script>
<canvas></canvas>
<script type="text/javascript">
    const canvas = document.querySelector('canvas');
    const gl = canvas.getContext("webgl2", {antialias: false})
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    const vertexShaderSource = `#version 300 es
    in vec2 position;
    void main() {
      gl_Position = vec4(position * 2.0 - 1.0, 0, 1.0);
    }`;
    const octaves = getSearchParams("octaves", "8");
    const scale = getSearchParams("scale", "7.0");
    const fragmentShaderSource = `#version 300 es
    #define fc gl_FragCoord
    #define OCTAVES ${octaves}
    #define SCALE ${scale}
    precision highp float;
    precision highp int;
    out vec4 color;
    uniform vec2 resolution;
    uniform float time;

    float pcg(vec2 p)
    {
        uint i;
        if (resolution.x > resolution.y)
            i = uint(floor(p.y) * SCALE + floor(p.x));
        else
            i = uint(floor(p.y)+ floor(p.x) * SCALE);


        uint state = i * 747796405u + 2891336453u;
        uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        return float((word >> 22u) ^ word) / float(0xffffffffu);
    }

    float noise (in vec2 st)
    {
        vec2 i = floor(st);
        vec2 f = fract(st);

        // Four corners in 2D of a tile
        float a = pcg(i);
        float b = pcg(i + vec2(1.0, 0.0));
        float c = pcg(i + vec2(0.0, 1.0));
        float d = pcg(i + vec2(1.0, 1.0));

        // Smooth Interpolation

        vec2 u = smoothstep(0.,1.,f);

        // Mix 4 corners percentages
        return mix(a, b, u.x) +
                (c - a)* u.y * (1.0 - u.x) +
                (d - b) * u.x * u.y;
    }

    float fbm(vec2 x)
    {
        float G = exp2(-1.0);
        float f = 1.0;
        float a = 1.0;
        float t = 0.0;
        float amplitude_sum = 0.0;
        for( int i=0; i<OCTAVES; i++)
        {
            t += a * noise(f * x);
            amplitude_sum += a;
            f *= 2.0;
            a *= G;
        }
        return t / amplitude_sum;
    }

    float pattern(vec2 p, out vec2 q, out vec2 r)
    {
        q = vec2( fbm(p + vec2(0.0,0.0)),
                       fbm(p + vec2(9999.-time/4.,time/4.)));

        r = vec2(fbm( p + 4.0*q + vec2(1.7,9.2) ),
                      fbm( p + 4.0*q + vec2(time,9999.-time)));

        return fbm(p + 4.0*r);
    }

    void main()
    {
        vec2 seed = fc.xy / max(resolution.x, resolution.y) * SCALE;
        vec2 o, n;
        float f = pattern(seed, o, n);
        vec3 col = vec3(f, o.x, n.x);

        col *= f*2.0;
        col = 1.0 - col;
        col *= col;
        color = vec4(col,1.0);
    }`
    const program = createProgram(
        gl,
        createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
        createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource));
    gl.useProgram(program);
    setPositions();
    const resolutionUniformLocation = gl.getUniformLocation(program, 'resolution');
    const timeUniform = gl.getUniformLocation(program, "time");
    let resized = true;
    window.onresize = () => resized = true;
    window.requestAnimationFrame(render);
    
    function getSearchParams(param, defaultValue) {
        const url = new URL(window.location.href);
        const params = url.searchParams;
        if (!params.has(param)) {
            params.set(param, defaultValue);
            window.history.replaceState({}, "", `${url.pathname}?${params}`);
        }
        return (params.get(param));
    }

    function render(timestamp) {
        updateUniforms(timestamp);
        const primitiveType = gl.TRIANGLES;
        const offset = 0;
        const count = 6;
        gl.drawArrays(primitiveType, offset, count);
        window.requestAnimationFrame(render)
    }

    function updateUniforms(timestamp) {
        if (resized) {
            resized = false;
            const size = getExactClientSize(canvas);
            canvas.width = Math.round(size.width * window.devicePixelRatio);
            canvas.height = Math.round(size.height * window.devicePixelRatio);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
        }
        gl.uniform1f(timeUniform, timestamp / 10000);
    }

    function getExactClientSize(element) {
        const rect = element.getBoundingClientRect();
        const computedStyle = getComputedStyle(element);
        const scaleX = rect.width / parseFloat(computedStyle.width);
        const scaleY = rect.height / parseFloat(computedStyle.height);

        const intrinsicWidth = rect.width / scaleX;
        const intrinsicHeight = rect.height / scaleY;

        return {width: intrinsicWidth, height: intrinsicHeight};
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader;
        }
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
    }

    function setPositions() {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,

            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
        ]), gl.STATIC_DRAW);
        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        const positionLocation = gl.getAttribLocation(program, 'position');
        const size = 2; // 2 components per iteration
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
        let offset = 0; // start at the beginning of the buffer
        gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
        gl.enableVertexAttribArray(positionLocation);
    }
</script>